
<!DOCTYPE html>
<html lang="zh-cn,en,default">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="为为技术文档">
    <title>为为技术文档</title>
    <meta name="author" content="weiwei02">
    
    
    
    <meta name="description" content="技术改变世界">
<meta property="og:type" content="blog">
<meta property="og:title" content="为为技术文档">
<meta property="og:url" content="https://weiwei02.github.io/index.html">
<meta property="og:site_name" content="为为技术文档">
<meta property="og:description" content="技术改变世界">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="为为技术文档">
<meta name="twitter:description" content="技术改变世界">
    
    
        
    
    
        <meta property="og:image" content="https://weiwei02.github.io/assets/images/weiwei.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-sxklfps8ywgfyyjcowvnb4gxdgt0zjts3hsguljmv9uqanxjbnitrovtbrek.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">为为技术文档</a>
    </div>
    
        
            <a  class="header-right-icon 技术，改变世界"
                href="#about">
        
        
            <i class="fa fa-lg fa-wewei.jpg"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/weiwei.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">weiwei02</h4>
                
                    <h5 class="sidebar-profile-bio"><p>技术，改变世界</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/weiwei02" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:weiwei02@vip.qq.com" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/08/09/framework/网站可伸缩架构分析/">
                            -架构设计-应用可伸缩架构分析
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-08-09T14:51:24+08:00">
	
		    8月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/架构/">framework</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  网站的伸缩性是指不需要改变服务器的硬件设计，仅仅靠改变应用服务器的部署数量，就可以扩大或缩小服务器的处理能力。一般来说，网站的伸缩性设计可分为两类，一类是根据功能进行物理分离实现伸缩，一类是单一功能通过集群实现伸缩。前者是不同服务器部署不同的服务，提供不同的功能。后者是集群中多台服务器部署相同的服务，提供相同的功能。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="依据功能实现伸缩"><a href="#依据功能实现伸缩" class="headerlink" title="依据功能实现伸缩"></a>依据功能实现伸缩</h2><p>  从网站发展早期，通过增加服务器提高网站处理能力时，新增服务器总是从现有服务器中分离出部分功能和服务。<br>  <img src="https://weiwei02.coding.me/images/framework/flexible/通过物理实现服务器伸缩.jpg" alt="通过物理实现服务器伸缩.jpg"><br>  图1 通过物理实现服务器伸缩</p>
<p>  图1所描述的伸缩性就是每次伸缩操作都会有更多的服务器加入网站，新增的服务器用于处理特定的服务。依据功能进行进行架构伸缩的具体实现方案有两种，纵向分离和横向分离。</p>
<ul>
<li><p><strong>纵向分离</strong><br>纵向分离是指服务根据业务流程上的不同部分分开进行部署，实现系统上的伸缩性，其分离方式如图2所示。<br><img src="https://weiwei02.coding.me/images/framework/flexible/纵向分离部署实现系统可伸缩性.jpg" alt="纵向分离部署实现系统可伸缩性.jpg"><br>图2 纵向分离部署实现系统可伸缩性</p>
</li>
<li><p><strong>横向分离</strong><br>横向分离又称为业务分割，其实现方式是将不同的业务模块分离部署，实现可伸缩性，如图3所示。根据系统的性能要求可以将横向分离的力度做到非常小。<br><img src="https://weiwei02.coding.me/images/framework/flexible/横向分离.jpg" alt="横向分离.jpg"><br>图3 横向分离部署实现系统可伸缩性</p>
</li>
</ul>
<h2 id="通过集群实现伸缩"><a href="#通过集群实现伸缩" class="headerlink" title="通过集群实现伸缩"></a>通过集群实现伸缩</h2><p>  将不同功能分离部署可以实现一定程度的伸缩性，但是随着网站访问量的逐步增加，即使分离到最小力度的独立部署，单一的服务器也不能满足业务规模的需求。此时可以使用服务器的集群，将相同的服务部署到多台服务器上构成一个集群整体对外提供服务。具体来说，集群伸缩性又可分为应用服务器集群伸缩性和数据服务器集群伸缩性。而数据服务集群也可分为缓存数据服务器集群和存储数据服务器集群。</p>
<h2 id="应用服务器集群的伸缩性设计"><a href="#应用服务器集群的伸缩性设计" class="headerlink" title="应用服务器集群的伸缩性设计"></a>应用服务器集群的伸缩性设计</h2><p>  应用服务器应该被设计成无状态的，即应用服务器不存储请求上下文信息，如果将部署有相同应用的服务器组成一个集群，用户的每一个请求都可以发送到任意一台服务器上去处理，任何一台服务器处理的结果都是相同的。这样只要能将用户请求按照某种规则分发到集群的不同服务器上，就可以构成一个应用服务器集群，每个用户的请求都可能落在不同的服务器上。<br>  如果HTTP请求分发装置可以感知或者可以配置集群服务器的数量，可以及时发现集群中新上线或下线的服务器，并能向新上线的服务器发送请求，停止向已下线的服务器分发请求，那么就实现了应用服务器的伸缩性。在这里，这个HTTP请求分发装置被称为负载均衡服务器。 使用负载均衡服务器实现应用服务器可伸缩架构如图4所示。<br>  <img src="https://weiwei02.coding.me/images/framework/flexible/负载均衡.jpg" alt="负载均衡.jpg"><br>  图4 负载均衡实现系统可伸缩性</p>
<p>  负载均衡是大型网站必不可少的技术手段，不但可以实现网站的可伸缩性，同时还可以改善网络的可用性。负载均衡的具体实现也多种多样，可以使用专有硬件也可以使用软件来实现。</p>
<h3 id="http重定向负载均衡"><a href="#HTTP重定向负载均衡" class="headerlink" title="HTTP重定向负载均衡"></a>HTTP重定向负载均衡</h3><p>  利用HTTP重定向协议实现负载均衡，如图5所示。<br>  <img src="https://weiwei02.coding.me/images/framework/flexible/请求重定向.jpg" alt="请求重定向.jpg"><br>  图5 HTTP请求重定向负载均衡原理</p>
<p>  HTTP重定向服务器时一台普通的WEB服务器，其唯一的功能就是根据用户的HTTP请求计算一台真实的WEB服务器地址，并将该WEB服务地址写入HTTP重定向响应中（响应状态码为302）返回给用户浏览器。这种负载均衡的优点是实现比较简单。缺点是浏览器需要两次请求服务器才能进行一次访问，性能较差。其次重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限。再者使用HTTP302响应状态码重定向，有可能使搜索引擎判断为SEO作弊，降低搜索引擎排名。</p>
<h3 id="dns域名解析负载均衡"><a href="#DNS域名解析负载均衡" class="headerlink" title="DNS域名解析负载均衡"></a>DNS域名解析负载均衡</h3><p>  这是利用DNS进行域名解析请求时进行负载均衡处理的一种方案。每次域名解析请求都会根据负载均衡算法可能计算出一个不同的IP地址，以后该用户对网站的请求都发送到这个地址上。如图6所示。<br>  <img src="https://weiwei02.coding.me/images/framework/flexible/DNS域名解析.jpg" alt="DNS域名解析.jpg"><br>  图6 DNS域名解析负载均衡原理</p>
<p>  在DNS服务器中配置多个A纪录，如： www.mysite.com IN A 10.0.0.1、www.mysite.com IN A 10.0.0.2、www.mysite.com IN A 10.0.0.3<br>  优点：将负载均衡的工作交给DNS，省掉了网站的管理维护负载均衡服务器的麻烦，同时许多DNS还提供了了基于地理位置的域名解析，即会将域名解析成距离用户地理位置最近的一个服务器地址，这样可加快用户的访问速度，改善性能。<br>  缺点：目前的DNS是多级DNS，每级DNS都可能对网站的DNS信息进行缓存，当下线某台服务器后，即使修改了DNS，也需要很长时间才能生效。其次，DNS负载均衡的控制权在域名运营商那里，网站无法做更多的改善和更强大的管理。<br>  在实际使用中，大型网站总是部分使用DNS域名解析，利用域名解析作为第一级负载均衡手段。</p>
<h3 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h3><p>  反向代理服务器在网络部署上位于WEB服务器之前，其拥有两个网卡，分别拥有内部和外部两套IP地址。在使用中它可以将外部网卡的请求转发到内部网卡连接的网络中的WEB服务器。WEB服务器的响应信息也需要反向代理服务器转发给用户。由于反向代理负载均衡工作在HTTP协议层面，因此也叫作应用层负载均衡。其逻辑架构图如图7所示。<br>  <img src="https://weiwei02.coding.me/images/framework/flexible/反向代理.jpg" alt="反向代理.jpg"><br>  图7 反向代理负载均衡原理</p>
<p>  优点：和反向代理服务器部署在一起，部署简单。<br>  缺点：反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。</p>
<h3 id="ip负载均衡"><a href="#IP负载均衡" class="headerlink" title="IP负载均衡"></a>IP负载均衡</h3><p>  IP负载均衡是在网络层修改目标IP地址来实现负载均衡，其网络架构图如图8所示。<br>  <img src="https://weiwei02.coding.me/images/framework/flexible/IP负载均衡.jpg" alt="IP负载均衡.jpg"><br>  图8 IP负载均衡原理</p>
<p>  IP负载均衡在处理真是物理WEB服务器的响应数据包时比较复杂。WEB服务器的响应包需要先返回到负载均衡服务器，再由负载均衡服务器转发给用户。响应的转发操作主要有两种实现方式：</p>
<ol>
<li>源地址转换（SNAT）：负载均衡服务器在修改目的地址时同时修改源地址，将数据包源地址修改为自身的地址，这样WEB服务器响应会再次回到自身。</li>
<li><p>负载均衡服务器同时作为真实服务器的网关设备，这样所有的响应数据都需要先来到负载均衡服务器上，再进行转发。</p>
<p>优点：在内核进程完成数据分发，较反向代理负载均衡（在应用中分发数据）有更好的处理性能。<br>缺点：所有的请求和回应都需要经过负载均衡服务器，集群的最大响应和吞吐量不得不受制于负载均衡服务器网卡的最大带宽。对于下载或视频服务等需要大量数据传输的手段而言，难以满足要求。</p>
</li>
</ol>
<h3 id="数据链路负载均衡"><a href="#数据链路负载均衡" class="headerlink" title="数据链路负载均衡"></a>数据链路负载均衡</h3><p>  数据链路负载均衡是在通信协议的数据链路层修改mac地址，来达到负载均衡的目的。负载均衡数据分发过程中不修改IP地址，只修改mac地址，通过配置真是物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一致，从而达到不修改数据包源地址和目的地址就可以进行数据分发的目的。由于实际处理请求的真是物理服务器IP和数据请求目的IP一致，不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种数据三角传输模式又成为直接路由方式（DR）。数据链路负载均衡网络架构如图9所示。<br>  <img src="https://weiwei02.coding.me/images/framework/flexible/数据链路.jpg" alt="数据链路.jpg"><br>  图7 数据链路负载均衡原理</p>
<p>  使用三角传输模式的数据链路层负载均衡是目前大型网站使用最广泛的一种负载均衡手段。在linux平台上最好的链路层负载均衡的开源产品是LVS（Linux Virtual Server）。</p>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>  负载均衡服务器的实现可分为两个部分：</p>
<ol>
<li>根据负载均衡算法和WEB服务器列表计算得到集群中一台WEB服务器的地址。</li>
<li><p>将请求发送到该地址所对应的WEB服务器上。</p>
<p>具体的负载均衡算法通常有以下几种：</p>
</li>
</ol>
<h3 id="轮询round-robin-rr"><a href="#轮询-Round-Robin-RR" class="headerlink" title="轮询(Round Robin, RR)"></a>轮询(Round Robin, RR)</h3><p>  所有请求依次呗分发到每台应用服务器上，即每台服务器要处理的请求数目都相同，适合所有服务器硬件都相同的场景。</p>
<h3 id="加权轮询weight-round-robin-wrr"><a href="#加权轮询-Weight-Round-Robin-WRR" class="headerlink" title="加权轮询(Weight Round Robin, WRR)"></a>加权轮询(Weight Round Robin, WRR)</h3><p>  根据应用服务器硬件性能的情况，在轮询的基础上，按照权重将请求分发到每个服务器，性能较高的服务器处理更多的请求。</p>
<h3 id="随机random"><a href="#随机-Random" class="headerlink" title="随机(Random)"></a>随机(Random)</h3><p>  请求被随机分配到各个应用服务器。随机也可以使用加权。</p>
<h3 id="最少连接least-connections"><a href="#最少连接-Least-Connections" class="headerlink" title="最少连接(Least Connections)"></a>最少连接(Least Connections)</h3><p>  纪录每个服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上。最少连接最符合负载均衡的定义，同样最少连接算法也能够使用加权。</p>
<h3 id="源地址散列source-hashing"><a href="#源地址散列-Source-Hashing" class="headerlink" title="源地址散列(Source Hashing)"></a>源地址散列(Source Hashing)</h3><p>  根据请求来源的IP地址进行hash计算，得到应用服务器，这样来自同一个IP地址的请求总在同一个服务器上处理，请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话黏滞。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>  本文是对可伸缩架构的学习笔记，笔记的内容并非是原创，而是大量参考其它资料。在写作本文的过程中引用了以下资料，为为在此深深谢过以下资料的作者。</p>
<ol>
<li>《大型网站技术架构·核心原理与案例分析》 李智慧 2013 电子工业出版社</li>
</ol>
<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>  我的<a href="https://github.com/weiwei02/" target="_blank" rel="external">github</a>: <a href="https://github.com/weiwei02/" target="_blank" rel="external">https://github.com/weiwei02/</a><br>  我相信技术能够改变世界。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/08/09/framework/网站可伸缩架构分析/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/08/03/database/theory/CAP原理/">
                            -数据库原理-数据CAP原理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-08-03T10:41:00+08:00">
	
		    8月 03, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/database/">database</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="高可用的数据"><a href="#高可用的数据" class="headerlink" title="高可用的数据"></a>高可用的数据</h2><p>   对于许多应用而言，数据是宝贵的，必须的资产。数据是整个应用的历史，是记录也有可能是配置信息，如果丢失了数据，那么对于某些应用来说结果可能就是毁灭性的，整个应用都有可能因此无法运行。<br>   不同于高可用的应用或服务的设计方式，由于数据存储服务器上存储的数据不同，当某台服务器宕机之后，数据访问请求不能任意的切换到集群中其它数据服务器上。</p>
<h2 id="cap"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>   CAP理论是分布式系统中对数据的管理而形成一套理论知识，CAP是设计分布式系统所必须考虑的架构问题。对于CAP本身可以解释如下：</p>
<ul>
<li>Consistency(一致性)： 数据一致更新，所有数据变动都是同步的</li>
<li>Availability(可用性)： 好的响应性能</li>
<li><p>Partition tolerance(分区耐受性)： 可靠性</p>
<p>上面的解释可能显得太过抽象，举例来说在高可用的网站架构中，对于数据基础提出了以下的要求：</p>
</li>
<li><p><strong>分区耐受性</strong><br>保证数据可持久存储，在各种情况下都不会出现数据丢失的问题。为了实现数据的持久性，不但需要在写入的时候保证数据能够持久存储，还需要能够将数据备份一个或多个副本，存放在不同的物理设备上，防止某个存储设备发生故障时，数据不会丢失。  </p>
</li>
<li><strong>数据一致性</strong><br>在数据有多份副本的情况下，如果网络、服务器、软件出现了故障，会导致部分副本写入失败。这就造成了多个副本之间的数据不一致，数据内容冲突。</li>
<li><p><strong>数据可用性</strong><br>多个副本分别存储于不同的物理设备的情况下，如果某个设备损坏，就需要从另一个数据存储设备上访问数据。如果这个过程不能很快完成，或者在完成的过程中需要停止终端用户访问数据，那么在切换存储设备的这段时间内，数据就是不可访问的。</p>
<p>CAP原理认为，一个提供数据服务的存储系统无法同时完美的满足一致性（Consistency）、数据可用性（Availability）、分区耐受性（Partition Tolerance）这三个条件。对于三者的关系见图1.</p>
<p><img src="/images/database/theory/CAP_theory.png" alt=""></p>

<p>图1 CAP原理关系图</p>
<p>在实际的大型网络应用中，数据的规模会快速扩张，因此数据架构的伸缩性（分区耐受性）必不可少。当规模变大之后，机器的数量也会增大，这时网络和服务器故障会更频繁出现，想要保证应用可用，就必须保证分布式处理系统的高可用性。所以在大型网站中，通常会选择强化分布式存储系统的可用性（A）和伸缩性（P），在某种程度上放弃一致性（C）。一般来说，数据不一致的情况通常出现在高并发写操作或者集群状态不稳（故障恢复，集群扩容…）的情况下，应用系统需要对分布式数据处理系统的数据不一致性有一定的了解并进行某种意义上的补偿工作，以避免应用出现数据不正确。  </p>
<p>CAP原理对于可伸缩的分布式系统设计具有重要的意义，在系统设计开发过程中，不恰当的迎合各种需求，企图打造一个完美的产品，可能会使设计进入两难之地，难以为继。<br>具体来说，数据一致性又可分为以下几点：</p>
</li>
<li><strong>数据强一致</strong><br>各个副本中的数据总是强一致的。这种设计正确性很高，但是会在一定程度上损耗性能。</li>
<li><strong>数据用户一致</strong><br>应用访问数据时通过一定的纠错和校验机制，把多个数据可能不一致的副本的数据综合计算返回一个一致且确定的数据给用户。大型互联网架构一般采用这种设计，性能较好，并且数据不会出现错误。</li>
<li><p><strong>数据最终一致</strong><br>物理存储的数据不一致，用户访问得到的数据也可能不一致，但经过一段时间的自我修正（通常很短时间），数据会达到最终一致。该设计性能最高，但可能有数据错误。</p>
<p>因为很难去同时满足CAP，大型网站通常会综合成本、技术、业务场景等条件，结合应用服务和其它的数据监控与纠错功能，使存储系统达到用户一致，保证用户最终访问数据的正确性。</p>
<blockquote>
<p>20170804 18:10:00 编辑到多种数据一致性</p>
</blockquote>
</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>本文是对class文件的学习笔记，笔记的内容并非是原创，而是大量参考其它资料。在写作本文的过程中引用了以下资料，为为在此深深谢过以下资料的作者。</p>
<ol>
<li>《大型网站技术架构·核心原理与案例分析》 李智慧 2013 电子工业出版社</li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/08/03/database/theory/CAP原理/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/07/21/jvm/class文件说明/">
                            class文件介绍
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-07-21T00:19:24+08:00">
	
		    7月 21, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/java/">java</a>, <a class="category-link" href="/categories/java/jvm/">jvm</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>非原创声明</p>
<blockquote>
<p>本文并非我的原创文章，而是我学习jvm时的笔记。文中的材料与数据大部分来自于其它资料，详细请查看本文的引用章节。</p>
</blockquote>
<h2 id="class文件介绍"><a href="#class文件介绍" class="headerlink" title="*.class文件介绍"></a>*.class文件介绍</h2><p>  一般来讲<em>.class文件是</em>.java文件在编译器编译后生成的jvm能够运行的文件，*.class文件又常被称为字节码文件。java在创始之初，就提倡“一次编写，处处运行的概念”，在当今编程圈中这个概念早已不是什么特例。java通过将开发人员所编写的java代码编译成class文件，然后由jvm虚拟机在执行时将不分平台的class文件中的字节码，再翻译成机器码，交给硬件执行。java就是靠jvm虚拟机的这个设计来实现与平台无关的特性的。class文件不但与硬件平台和操作系统无关，也和具体的编程语言无关，就目前来说，如函数式编程语言scala与Groovy都可以通过自己的编译器将源代码编译成class文件，在jvm上运行。<br>  综合来讲，class文件有以下两点特性：</p>
<ul>
<li>与硬件和操作系统平台无关</li>
<li>与源码所使用的编程语言无关</li>
</ul>
<h2 id="class类文件的结构"><a href="#class类文件的结构" class="headerlink" title="class类文件的结构"></a>class类文件的结构</h2><blockquote>
<p>每一个class文件都唯一对应着java类或接口枚举等定义信息，但类不一定都定义在class文件中，类可能是由类加载器动态生成的。</p>
</blockquote>
<p>  class文件所以被称之为字节码据我猜测可能是因为class文件以8位（1字节）为单位进行存储的二进制信息。<strong>字节码中各个数据项目严格按照顺序紧凑的排列，中间没有任何分割符。</strong>在需要存储整型或浮点型这些大于8位的数据项目时，则会使用Big-Endian的字节序进行存储，将最高位字节放在地址最低位，最低位字节放在地址最高位。</p>
<p>  class文件格式采用表来存储数据，表中有无符号数和表两种数据类型。对于这两种数据类型说明如下：</p>
<ul>
<li><strong>无符号数</strong>： 无符号数是基本的数据类型，可以用来表示数字、索引引用、数量值或者按照UTF-8编码构成的字符串。如u1,u2,u4,u8分别代表1,2,4,8个字节字节的无符号数。</li>
<li><strong>表</strong>： 表是由多个无符号数或者其它表作为数据项所组成的复合数据结构，表用于描述层次关系和复合的数据结构，整个class文件就是一张表。通常表以 _info 结尾。如表1就是一个class的表示例。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">数量  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">u4</td>
<td style="text-align:center">magic</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">minor_version</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">major_version</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">constant_pool_count</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">cp_info</td>
<td style="text-align:center">constant_pool</td>
<td style="text-align:center">constant_pool_count - 1</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">asscess_flags</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">this_class</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">super_class</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">interfaces_count</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">interfaces</td>
<td style="text-align:center">interfaces_count</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">fields_count</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">field_info</td>
<td style="text-align:center">fields</td>
<td style="text-align:center">fields_count</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">methods_count</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">method_info</td>
<td style="text-align:center">methods</td>
<td style="text-align:center">method_count</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">attributes_count</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">attribute_info</td>
<td style="text-align:center">attributes</td>
<td style="text-align:center">attributes_count</td>
</tr>
</tbody>
</table>
<p><em>表 1 class文件格式</em></p>
<p>   class文件的顺序和格式必须严格实现按照上述规则，否则jvm将不能识别执行。</p>
<h3 id="magic-number-魔数"><a href="#Magic-Number-魔数" class="headerlink" title="Magic Number 魔数"></a>Magic Number 魔数</h3><blockquote>
<p>魔数是一个和文件后缀名相似的用于文件格式识别的约定，一般规定文件内容开头的前几个字节为文件的魔数。不同于文件后缀名很容易被用户以重命名的方式进行更改，文件的魔数作为识别手段可以更安全的确定文件的可用性。</p>
</blockquote>
<p>  class文件使用前4个字节作为魔数，来确定.class文件是否是一个能够被虚拟机识别的文件，其值是 0xCAFFEBABE 。</p>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>   class文件的第5-6个字节代表的可执行该class文件的目标虚拟机的最低次版本号(Minor Version)，第7-8个字节是主版本号(Major Version)。java虚拟机可以运行比当前虚拟机版本号低的class文件，拒绝运行版本号不合法，或比自己版本高的class文件。JDK1.1的版本号是45，之后的每个大版本发布都把主版本号加1，如JDK1.2主版本号是46，JDK8的版本号是52。<br>   JDK在编译java文件是可以通过 <code>javac -target 1.6 ...</code>命令来指定编译后的class文件可以在1.6的虚拟机版本上运行。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><blockquote>
<p>常量池是class文件中第一个表类型的数据项目，常量池是class文件中的资源仓库，是class文件结构中与其它项目关联最多的数据类型，也是占用class文件空间最大的数据项目之一。</p>
</blockquote>
<p>   class文件里紧随版本之后的数据项是常量池，由于常量池的数量是不固定的，所以在常量池的数据项之前放置的有一个u2类型的数据，代表常量池的大小。常量池大小的初始值是1，如常量池的大小的数据如果显示的是10，就代表该class文件中有9个常量。<br>   常量池中主要存放两大类常量：Literal(字面常量)、Symbolic Reference(符号引用常量)。字面常量类似于java中常量的概念，如文本字符串、final关键字所声明的常量等。而符号引用常量则是编译中的概念，主要包括以下三种类型的常量。</p>
<ul>
<li><p>符号常量</p>
<ul>
<li>类和接口的全限定名(Fully Qualified Name)</li>
<li>字段名称和描述符(Descriptor)</li>
<li>方法的名称和描述符</li>
</ul>
<p>class文件中不会保存各个方法或字段在内存中的布局信息，而是在虚拟机加载class文件时进行动态的连接。虚拟机在运行class文件时从常量池中获取对应的符号引用，再在创建类或者运行时解析连接到具体的内存地址当中。<br>常量池中的每一个常量都是一个表，在JDK8中有14种表结构的常量表。如表 2 所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">标识</th>
<th style="text-align:center">描述　</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONSTANT_utf8_info</td>
<td style="text-align:center">1　</td>
<td style="text-align:center">UTF-8编码的字符串</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Integer_info</td>
<td style="text-align:center">3</td>
<td style="text-align:center">整形字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Float_info</td>
<td style="text-align:center">4</td>
<td style="text-align:center">浮点型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Long_info</td>
<td style="text-align:center">５</td>
<td style="text-align:center">长整型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Double_info</td>
<td style="text-align:center">６</td>
<td style="text-align:center">双精度浮点型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Class_info</td>
<td style="text-align:center">７</td>
<td style="text-align:center">类或接口的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_String_info</td>
<td style="text-align:center">８</td>
<td style="text-align:center">字符串类型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Fieldref_info</td>
<td style="text-align:center">９</td>
<td style="text-align:center">字段的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Methodref_info</td>
<td style="text-align:center">１０</td>
<td style="text-align:center">类中方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_InterfaceMethodref_info</td>
<td style="text-align:center">１１</td>
<td style="text-align:center">接口中方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_NameAndType_info</td>
<td style="text-align:center">１２</td>
<td style="text-align:center">字段或方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_MothodType_info</td>
<td style="text-align:center">１６</td>
<td style="text-align:center">标志方法类型</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_MethodHandle_info</td>
<td style="text-align:center">１５</td>
<td style="text-align:center">表示方法句柄</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_InvokeDynamic_info</td>
<td style="text-align:center">１８</td>
<td style="text-align:center">表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<p>   <em>表 2 常量池数据项目类型表</em>  </p>
<p>   这14种常量结构表开始的第一个字节都是一个u1类型的标识位，其值就是表2中每项常量表类型所对应的标识列的值，代表当前常量属于哪种常量类型。这14种常量类型各自有自己不同的表结构，详情如表 3 所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th style="text-align:center">项目</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONSTANT_Utf8_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">值为1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">length</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">UTF-8编码的字符串占用的字节数</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">bytes</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">utf-8编码的字符串</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Integer_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">值为3</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">bytes</td>
<td style="text-align:center">u4</td>
<td style="text-align:center">按照Big-Endian存储的int值</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Float_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">bytes</td>
<td style="text-align:center">u4</td>
<td style="text-align:center">按照Big-Endian存储的float值</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Long_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">bytes</td>
<td style="text-align:center">u8</td>
<td style="text-align:center">按照Big-Endian存储的long值</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Double_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">bytes</td>
<td style="text-align:center">u8</td>
<td style="text-align:center">按照Big-Endian存储的long值double值</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Class_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向全限定名常量项的索引</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_String_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向字符串常量的索引</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Fieldref_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向声明字段的类或接口描述符CONSTANT_Class_info的索引值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向CONSTANT_NameAndType_info的索引值</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Methodref_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向声明方法的类描述符CONSTANT_Class_info的索引值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向CONSTANT_NameAndType_info的索引值</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_InterfaceMethodref_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向声明方法的接口描述符CONSTANT_Class_info的索引值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向CONSTANT_NameAndType_info的索引值</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_NameAndType_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向该字段或方法名称常量的索引值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向该字段或方法描述符常量的索引值</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_MethodHandle_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">reference_kind</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">值必须1~9，它决定了方法句柄的的类型。方法句柄类型的值表示方法句柄的字节码行为</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">reference_index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">对常量池的有效索引</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_MethodType_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">description_index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">对常量池中方法描述符的有效索引常量池在该处的索引必须是CONSTANT_Utf8_info的结构，表示方法的描述符。</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_InvokeDynamic_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">18</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">bootstap_method_attr_index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">对当前class文件中引导方法表的bootstap_methods[]数组的有效索引</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">name_and_type_index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">对当前常量池的有效索引，常量池在此处必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述。</td>
</tr>
</tbody>
</table>
<p>   <em>表 3 常量池中14中常量的结构总表</em></p>
<p>   在表 3 中可以看到class文件所支持的所有的常量的结构信息，另外由于class中的类名、方法、字段都要用CONSTANT_Utf8_info型的常量来描述名称，所以CONSTANT_Utf8_info的最大长度也是java中类名、方法名或字段的最大长度65535，如果超出这个最大长度，便会无法编译。</p>
<h3 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h3><p>  在class文件中位于常量池之后的是访问权限标识。class文件的访问标识是用于修饰这个class文件所代表的的类或接口本身的一些属性。访问标识是用一个u2类型的数据来代表的，如0x0001代表public，0x0020代表这是一个接口。具体的访问标识和标志值的对应关系见表4.访问标识是按位进行标识的，一个u2类型的数据有16位，目前其中的8位都被赋予了实际意义。</p>
<table>
<thead>
<tr>
<th style="text-align:left">标识名称</th>
<th style="text-align:left">标识值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td style="text-align:left">0X0001</td>
<td>public的访问权限</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td style="text-align:left">0x0010</td>
<td>如果该class文件代表一个类，那么该类是final修饰的(只能类才能拥有此标识)</td>
</tr>
<tr>
<td style="text-align:left">ACC_SUPER</td>
<td style="text-align:left">0x0020</td>
<td>使用invokespecial字节码指令的新语义</td>
</tr>
<tr>
<td style="text-align:left">ACC_INTERFACE</td>
<td style="text-align:left">0x0200</td>
<td>接口</td>
</tr>
<tr>
<td style="text-align:left">ACC_ABSTRACT</td>
<td style="text-align:left">0x0400</td>
<td>abstract（只有接口和抽象类有效）</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td style="text-align:left">0x10000</td>
<td>本类不是用户代码所产生的类</td>
</tr>
<tr>
<td style="text-align:left">ACC_ANNOTATION</td>
<td style="text-align:left">0x2000</td>
<td>注解</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td style="text-align:left">0x4000</td>
<td>枚举</td>
</tr>
</tbody>
</table>
<p>表4 访问标识和标志值的对应关系表</p>
<h3 id="类索引"><a href="#类索引" class="headerlink" title="类索引"></a>类索引</h3><p>  类索引是一个u2类型的数据，用于确定这个类的全限定名。其索引值指向一个类型为CONSTANT_Class_info的常量。</p>
<h3 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h3><p>  父类索引指向着当前类所继承的类的父类的全限定名，其类型信息与类索引相同。所有java类都有父类索引。</p>
<h3 id="接口索引"><a href="#接口索引" class="headerlink" title="接口索引"></a>接口索引</h3><p>  java不支持多重继承，所以只有一个父类索引。但一个java类或接口可以实现多个其它接口，所以class的接口索引是一个数量并不固定的集合。<br>  在声明接口索引之前，class文件首先会声明一个u2类型的数据代表接口索引的总数量，其后面紧跟者就是接口索引集合，如果该类没有实现任何接口，那么接口索引的总数量的值就是0。接口索引同样也指向常量池中的CONSTANT_Class_info类型的常量，使用CONSTANT_Utf8_info的字符串常量来表示接口的全限定名。</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><blockquote>
<p>20170701 00:10:00 编辑到字段表集合</p>
</blockquote>
<p>   字段集合用于<code>描述</code>接口或类中所声明的全局变量。如public，static、final等词都是用来描述某个字段的修饰词。因为java中可用来修饰字段的修饰符有限，所以class文件对于字段的修饰符的表示是通过使用标识位来实现的。表5详细分析了字段表的数据结构。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">access_flags</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">name_index</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">attributes_count</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">attrobute_info</td>
<td style="text-align:left">attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<p>   表5 字段表的数据结构</p>
<p>   access_flags标识位中存放的是字段的修饰符，使用标志位进行标识区分。具体区分方式如表6字段访问标识表所示。</p>
<table>
<thead>
<tr>
<th style="text-align:left">标识名称</th>
<th style="text-align:left">标识值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td style="text-align:left">0x0001</td>
<td>public</td>
</tr>
<tr>
<td style="text-align:left">ACC_PRIVATE</td>
<td style="text-align:left">0x0002</td>
<td>private</td>
</tr>
<tr>
<td style="text-align:left">ACC_PROTECTED</td>
<td style="text-align:left">0x0004</td>
<td>protected</td>
</tr>
<tr>
<td style="text-align:left">ACC_STATIC</td>
<td style="text-align:left">0x0008</td>
<td>static</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td style="text-align:left">0x0010</td>
<td>final</td>
</tr>
<tr>
<td style="text-align:left">ACC_VOLATILE</td>
<td style="text-align:left">0x0040</td>
<td>volatile</td>
</tr>
<tr>
<td style="text-align:left">ACC_TRANSIENT</td>
<td style="text-align:left">0x0080</td>
<td>transient</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td style="text-align:left">0x1000</td>
<td>该字段是否由编译器自动生成的</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td style="text-align:left">0x4000</td>
<td>字段是否是enum</td>
</tr>
</tbody>
</table>
<p>   表6 字段访问标识对应表</p>
<p>   name_index 和 descriptor_index 都是对常量池索引的引用，name_index引用的是字段的名称，descriptor_index引用的是字段和方法的描述符。</p>
<blockquote>
<p>20170801 00:10:00 编辑到字段表集合</p>
</blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>  本文是对class文件的学习笔记，笔记的内容并非是原创，而是大量参考其它资料。在写作本文的过程中引用了以下资料，为为在此深深谢过以下资料的作者。</p>
<ol>
<li>《The Java Virtual Machine Specification》</li>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践/周志明著.——2版.——北京：机械工业出版社，2013.6》</li>
</ol>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>  本项目和文档中所用的内容仅供学习和研究之用，转载或引用时请指明出处。如果你对文档有疑问或问题，请在项目中给我留言或发email到 weiwei02@vip.qq.com</p>
<blockquote>
<p>from weiwei.wang 20170625</p>
</blockquote>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/07/21/jvm/class文件说明/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/07/02/jvm/001-java内存模型/">
                            java内存模型
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-07-02T00:19:24+08:00">
	
		    7月 02, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/java/">java</a>, <a class="category-link" href="/categories/java/jvm/">jvm</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>非原创声明</p>
<blockquote>
<p>本文并非我的原创文章，而是我学习jvm时的笔记。文中的材料与数据大部分来自于其它资料，详细请查看本文的引用章节。</p>
</blockquote>
<h2 id="java内存模型"><a href="#JAVA内存模型" class="headerlink" title="JAVA内存模型"></a>JAVA内存模型</h2><p>   犹记得大学时操作系统课上，我们迷茫的眼神注视着带着厚眼镜教授向我们一遍遍的强调，一个程序最少有一个进程组成，进程是操作系统提供独立资源供应用程序运行的基本单位。另外老师向我们讲到，为了更好的提高计算机的并行计算能力，计算机科学家们又设计了线程。线程是比进程更小的单位，一个进程可以由多个线程组成。同时线程也是在得到cpu时间片时可运行的最小的单位。尤记得在这些理论基础下，我慢慢的学会了使用C在LINUX环境下使用多进程和多线程进行编程。这些并发API都是LINUX提供的标准API，程序在编译链接之后可以直接调用通过系统内核创建进程或线程，在类UNIX操作系统下这样去做可以让程序有更高的性能。但是这种编程方式所编写出来的代码是与操作系统绑定的，我在linux下明明可以完美运行的代码，在windows下连编译甚至都做不到。除非是用 windows API重新把与操作系统进行交互的那些代码给替换掉，否则就不要想着让程序去跨平台运行了。<br>   在进行并发编程时相对于C，我更喜欢java的编程体验。java消除操作系统之间的差异，原生的对多线程应用提供了很好的支持，特别是在jdk1.5之后，jdk还提供了currency包，更好的让程序员们无需去关注并发的难点与细节，更专心的关注应用的业务需求实现。<br>   在多线程编程中最长遇到的问题就是线程安全问题，其中又以内存中的数据安全问题最为常见(这个数据安全指的是发生脏读、幻读等并发编程中会遇到的错误)。为了消除不同硬件和操作系统对内存操作的差异，在硬件设备和操作系统的内存模型之上，java虚拟机规范定义了一种java内存模型(JAVA Memory Model,简称JMM)，将内存分为了工作内存和主内存。JMM主要定义了JVM中在内存中操作变量的规则和细节，用来解决在并发竞争对变量操作时可能会发生的各种问题。JMM完全兼容CPU的多级cache机制，并且支持编译器的代码重排序。<br>   注意：JMM内存模型的概念不同于jvm中6大内存区域的概念，两者不可强行混为一谈。</p>
<h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p>  JMM规定了所有的全局变量都存于主内存(Main Memory)中，一般情况下这些全局变量都会被保存到堆里。每个线程都有自己的工作内存(Working Memory)，工作内存中会保存当前线程所需用到的主内存中全局变量的拷贝和自己的局部变量。一般情况下工作内存指的是栈内存，从物理上来讲，工作内存一般情况下都会工作于cpu的cache里。一个线程对全局变量的任何操作必须在自己的工作内存中进行，不允许直接操作工作内存。不同线程不能访问对方的工作内容，只能通过主内存进行数据交换。<br>  <img src="https://weiwei02.coding.me/images/java/jvm/JMM交互关系图.png" alt=""><br>  </p>
<blockquote>
<p>工作内存在对主内存中变量做拷贝时，如果变量是基本类型的，则会拷贝其值；如果是引用类型的，那么仅仅会拷贝其引用</p>
</blockquote>
<h3 id="jmm内存操作"><a href="#JMM内存操作" class="headerlink" title="JMM内存操作"></a>JMM内存操作</h3><p>JMM定义了8种主内存与工作内存之间的具体交互操作，虚拟机在实现JMM时必须保证每种内存操作都是原子的。表1详细列出了JMM的8种内存操作。</p>
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">操作名</th>
<th style="text-align:left">作用区域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">lock</td>
<td style="text-align:left">锁定</td>
<td style="text-align:left">主内存</td>
<td>把一个变量标识为一个线程独占的状态</td>
</tr>
<tr>
<td style="text-align:left">unlock</td>
<td style="text-align:left">解锁</td>
<td style="text-align:left">主内存</td>
<td>把一个处于锁定状态的变量释放出来</td>
</tr>
<tr>
<td style="text-align:left">read</td>
<td style="text-align:left">读取</td>
<td style="text-align:left">主内存</td>
<td>把一个变量的值从主内存读取到工作内存中，以便于随后的load指令使用</td>
</tr>
<tr>
<td style="text-align:left">load</td>
<td style="text-align:left">载入</td>
<td style="text-align:left">工作内存</td>
<td>把read指令从主内存中读取的变量值放入到工作内存的变量副本中</td>
</tr>
<tr>
<td style="text-align:left">use</td>
<td style="text-align:left">使用</td>
<td style="text-align:left">工作内存</td>
<td>将工作内存中一个变量的值传递给执行引擎</td>
</tr>
<tr>
<td style="text-align:left">assign</td>
<td style="text-align:left">赋值</td>
<td style="text-align:left">工作内存</td>
<td>把一个从执行引擎接收到的值赋给工作内存的变量</td>
</tr>
<tr>
<td style="text-align:left">store</td>
<td style="text-align:left">存储</td>
<td style="text-align:left">工作内存</td>
<td>把一个工作内存中变量的值传送到主内存中，以便于随后的write指令使用</td>
</tr>
<tr>
<td style="text-align:left">write</td>
<td style="text-align:left">写入</td>
<td style="text-align:left">主内存</td>
<td>把store指令从工作内存传出的变量的值写入到主内存的变量中</td>
</tr>
</tbody>
</table>
<p>表1 JMM内存操作指令表</p>
<blockquote>
<p>20170702 01:48 编辑到JMM内存操作指令表</p>
</blockquote>
<p>JMM规定了在使用以上8种内存操作时必须遵守以下规则：</p>
<ul>
<li>read,load或store,write必须成对出现。如：执行read操作从主内存读取一个变量后，必须在工作内存使用load载入这个变量。两者之间的顺序不可错，但两者之间可以穿插其它指令。同理，在工作内存中对一个变量使用了store指令，必须在主内存中使用write指令进行写入。</li>
<li>不允许一个线程丢弃它最近做的assign操作。变量在工作内存中改变了之后必须将这个变化同步到主内存中。</li>
<li>不允许一个线程没有发生过assign操作就将数据从工作内存同步到主内存。</li>
<li>只能在主内存中新建全局变量，不能在工作内存中直接使用一个未被初始化的变量。可以使用assign和load指令在工作内存对一个变量进行初始化操作。</li>
<li>一个变量在同一时刻只能被一个线程执行lock操作。</li>
<li>如果对一个变量执行lock，那将清空工作内存中此变量的值。在执行引擎使用这个变量之前，需要重新load或assign重新初始化变量的值。</li>
<li>unlock只能解锁被本线程锁定的变量。</li>
<li>对一个变量执行unlock之前，必须将此变量同步回主内存。</li>
</ul>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>volatile是java语言所提供的关键字，使java最轻量级的内存同步的措施。与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。   </p>
<p>java中锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 。<br>volatile 变量具有 synchronized 的可见性特性，但是不具备锁的原子特性。所以即便volatile没有不一致的问题，但volatile变量在并发的运算下并不是原子操作，所以依然可能会有安全问题。</p>
<pre><code>package com.github.weiwei02.jvm.jmm.volatile_test;

/**
* volatile 线程安全性测试
* @author Wang Weiwei &lt;email&gt;weiwei02@vip.qq.com / weiwei.wang@100credit.com&lt;/email&gt;
* @version 1.0
* @sine 2017/7/2
*/
public class VolatileTest {
public static volatile int race = 0;
public static final int THREAD_COUNT=20;

public static void main(String[] args) {
    Thread threads[] = new Thread[THREAD_COUNT];
    System.out.println(race);
    for (int i =0; i &lt; THREAD_COUNT; i++){
        threads[i] = new Thread(() -&gt; {
            for (int j = 0; j &lt; 1000 ; j++) {
                increase();
            }
        });
        threads[i].start();
    }


    //等待所有累加线程都结束
    while (Thread.activeCount() &gt; 1){
        Thread.yield();
    }

    //等待所有线程执行完毕之后，打印race的最终值
    System.out.println(race);
}

private static void increase() {
    race++;
}
}
</code></pre><p>   代码1 volatile 线程安全测试</p>
<p>   程序的执行结果如图2所示。<br>   <img src="https://weiwei02.coding.me/images/java/jvm/volatile数据错误1.png" alt="volatile 线程安全测试"><br>   图2 volatile 线程安全测试</p>
<p>   这个程序执行的结果应该是20000，可实际执行所得到的结果只有18439.并且多次执行本程序都会得到不一样的结果。所以会出现这种情况的原因是 race++ 这个操作并不是原子操作，volatile关键字只能保证在使用race变量时，工作线程能够从主内存中拿取最新的race的值，并不能保证进行过++操作之后写回到主内存期间其它线程没有对race变量进行修改。<br>   volatile关键字只能保证可见性，只有在以下两种条件下，我们可以认为volatile是线程安全的；</p>
<ol>
<li>运算结果并不依赖变量的当前值，或者能够保证只有一个线程修改变量的值。</li>
<li><p>变量不需要与其它的变脸共同参与不变约束。</p>
<p>当不符合这两种条件时，想要保证volatile变量的原子性，只能通过 <strong>锁</strong> 机制来实现。</p>
<p>volatile变量的第二个重要作用是禁止编译器进行指令重排序。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。从硬件层面上来讲，是指CPU允许多条指令不按程序规定的顺序分开发送到个相应的电路单元来处理。CPU必须要正确的处理指令的依赖情况，不能将指令任意的排序。比如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3将地址B中的值减去3。在这一系列指令中，指令1,2之间是有依赖关系的，不能进行重排序。但指令3的执行顺序可以改到指令1之前也可以放到指令1之后，只要能够保证在执行完毕这三条指令程序中A，B的值是正确的即可。volatile在某些情况下性能高于锁，由于虚拟机对锁实行有多种消除和优化，我们很难衡量volatile会比锁快多少。</p>
</li>
</ol>
<h3 id="原子性-可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3><blockquote>
<p>20170803 23:11:51 原子性、可见性和有序性<br>   JAVA内存模型的核心问题时为了解决多线程应用中的原子性、可见性与有序性的问题，保证了这三点才能使多线程应用有数据安全性可言。</p>
<ul>
<li><strong>原子性 (Atomicity)</strong><br>由java内存模型来直接保证原子性的操作包括read、load、assign、use、store和write。对于一个变量的基本读写操作都是具有原子性的。如果需要对多种这几种基本读写操作的操作集合保证原子性，可以使用lock和unlock。</li>
<li><strong>可见性(Visibility)</strong><br>可见性是指当变量的值被一个线程修改了之后，其它线程能够立即知道这个修改。JAVA内存模型时通过变量内容修改后立刻同步到主内存，读取变量的值之前先从内存刷新这种方式来保证可见性。JAVA中除了volatile之外还有synchronized、final两个关键字能够实现内存可见性。synchronized的可见性是由”对一个变量执行unlock操作之前，必须先把此变量同步会主内存中（执行store，write操作）”这条规则获得的。final的可见性是由于被final修饰的变量在构造器中一旦被初始化完成，并且构造器没有吧this的引用传递出去（this引用是一件非常危险的事，其它线程可能通过这个引用访问到初始化一半的对象），，那在其它线程中就能看见final变量的值。</li>
<li><strong>有序性</strong><br>如果在本线程内观察，所有的操作都是有序的，如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句指的是“线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics)，后半句指的是“指令重排序”现象和“工作内存与主内存同步延迟”现象。</li>
</ul>
</blockquote>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><blockquote>
<p>20170804 02:02:23 先行发生原则</p>
</blockquote>
<p>  先行发生原则（Happens-before）是JAVA内存模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，操作A造成的影响就能被操作B观察到。JAVA只能怪的先行发生原则无需任何同步协助，可以直接编码使用。以下列出JAVA中的先行发生原则，如果两个操作之间的关系不在下面的规则中，且无法通过下面的规则推导出来，虚拟机就能随意的对他们进行指令重排序。  </p>
<ul>
<li><p><strong>程序次序规则（Program Order Rule)</strong><br>：在一个线程内，按照程序的代码顺序，书写在前的操作先于书写在后面的操作发生。准确的说，应该是控制流顺序而不是程序代码顺序，因为需要考虑分支、循环等结构。</p>
</li>
<li><p><strong>管程锁定规则（Monitor Lock Rule）</strong><br>： 一个unlocak操作先行发生于后面对同一个锁的lock操作。</p>
</li>
<li><p><strong>volatile变量规则（Volatile Variable Rule）</strong><br>：对一个volatile的写操作，先行发生于后面对这个变量的读操作。</p>
</li>
<li><p><strong>线程启动规则（Thread Start Rule）</strong><br>：线程的start方法先行发生于此线程的每一个动作。</p>
</li>
<li><p><strong>线程终止规则（Thread Termination Rule）</strong><br>： 线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.jion()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</p>
</li>
<li><p><strong>线程中断原则（Thread Interruption Rule）</strong><br>：对线程的interrupt()方法的调用先行发生于被中断的线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</p>
</li>
<li><p><strong>对象终结规则（Finalizer Rule）</strong><br>：一个对象的初始化完成（够构造函数执行结束）先行发生于它的fnalize()方法开始。</p>
</li>
<li><p><strong>传递性（Transitivity）</strong><br>：如果A操作先行发生于B操作，B操作先行发生于C操作，就可以得出A先行发生于C的结论。</p>
<p>时间先后顺序与先行发生原则之间基本没有关系，所以当我们需要衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p>
<blockquote>
<p>20170804 23:59:46 先行发生原则</p>
</blockquote>
</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>  本文是对class文件的学习笔记，笔记的内容并非是原创，而是大量参考其它资料。在写作本文的过程中引用了以下资料，为为在此深深谢过以下资料的作者。</p>
<ol>
<li>《The Java Virtual Machine Specification》</li>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践/周志明著.——2版.——北京：机械工业出版社，2013.6》</li>
</ol>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>  原文链接 <a href="https://weiwei02.github.io/2017/07/02/jvm/001-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">https://weiwei02.github.io/2017/07/02/jvm/001-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</a><br>  我的<a href="https://github.com/weiwei02/" target="_blank" rel="external">github</a>: <a href="https://github.com/weiwei02/" target="_blank" rel="external">https://github.com/weiwei02/</a><br>  我相信技术能够改变世界。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/07/02/jvm/001-java内存模型/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/02/04/bigdata/hadoop/并行计算框架介绍/">
                            MapReduce并行计算框架介绍
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-02-04T00:19:24+08:00">
	
		    2月 04, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/bigdata/">bigdata</a>, <a class="category-link" href="/categories/bigdata/hadoop/">hadoop</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="关于mapreduce"><a href="#关于MapReduce" class="headerlink" title="关于MapReduce"></a>关于MapReduce</h1><p>   MapReduce是一种可用于数据处理的编程模型。MapReduce程序本质上是并行运行的，<br>   因此可以将大规模的数据分析任务分发给任何一个拥有足够多机器的数据中心，充分利用Hadoop<br>   提供的并行计算的优势。</p>
<h2 id="使用hadoop来分析数据"><a href="#使用Hadoop来分析数据" class="headerlink" title="使用Hadoop来分析数据"></a>使用Hadoop来分析数据</h2><p>   MapReduce任务过程分为两个处理阶段：map阶段和reduce阶段。每个阶段都以键/值对作为<br>   输入和输出，其类型由程序员来选择。程序员还需要写两个函数，map函数和reduce函数.<br>   示例取自《Hadoop权威指南-第三版》</p>
<h4 id="1-创建查找最高气温的mapper类"><a href="#1-创建查找最高气温的Mapper类" class="headerlink" title="1. 创建查找最高气温的Mapper类"></a>1. 创建查找最高气温的Mapper类</h4><pre><code>package com.hadoopbook.ch02;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

import java.io.IOException;

/**
 * [@author](https://my.oschina.net/arthor) WangWeiwei
 * [@version](https://my.oschina.net/u/931210) 1.0
 * [@sine](https://my.oschina.net/mysine) 17-2-4
 * 查找最高气温的mapper类
 */
public class MaxTemperatureMapper extends  Mapper&lt;LongWritable,Text,Text,IntWritable&gt; {
    private static final int MISSING = 9999;

    @Override
    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
        String line = value.toString();
        String year = line.substring(15,19);
        int airTemperature;
        if (line.charAt(87) == &apos;+&apos;){
            // parseInt doesn&apos;t like leading plus signs
            airTemperature = Integer.parseInt(line.substring(88, 92));
        }else {
            airTemperature = Integer.parseInt(line.substring(87, 92));
        }
        String quality = line.substring(92, 93);
        if (airTemperature != MISSING &amp;&amp; quality.matches(&quot;[01459]&quot;)) {
            context.write(new Text(year), new IntWritable(airTemperature));
        }
    }

    public MaxTemperatureMapper() {
        super();
    }
}
</code></pre><p>   这个mapper类是一个泛型类型，它有四个形参类型，分别指定map函数的输入键/输入值/输出键和输出值的类型。<br>   Hadoop本身提供了一套可优化网络序列化传输的基本类型，而不是直接使用java内嵌的类型。这些类型都在<br>   org.apache.hadoop.io包里。<br>   map() 方法的输入是一个键和一个值，方法还提供了context实例用于输出内容的写入。</p>
<h4 id="2-查找最高气温的reducer类"><a href="#2-查找最高气温的reducer类" class="headerlink" title="2. 查找最高气温的reducer类"></a>2. 查找最高气温的reducer类</h4><p>   类似于上的方法，使用Reducer来定义reduce函数.</p>
<pre><code>package com.hadoopbook.ch02;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

import java.io.IOException;

/**
 * [@author](https://my.oschina.net/arthor) WangWeiwei
 * @version 1.0
 * @sine 17-2-4
 * 查找最高气温的Reducer类
 */
public class MaxTemperatureReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; {
    public MaxTemperatureReducer() {
        super();
    }

    @Override
    protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
        int maxValue = Integer.MIN_VALUE;
        for (IntWritable value : values){
            maxValue = Math.max(maxValue, value.get());
        }
        context.write(key,new IntWritable(maxValue));
    }
}
</code></pre><p>   同样，reduce函数也有四个形式参数类型用于指定输入和输出类型。reduce函数的输入类型必须匹配map函数<br>   的输出类型：即TEXT类型和IntWritable类型。</p>
<h4 id="3-mapreduce作业"><a href="#3-MapReduce作业" class="headerlink" title="3. MapReduce作业"></a>3. MapReduce作业</h4><p>   指定一个作业对象，在这个应用中用来在气象数据集中找出最高气温</p>
<pre><code>package com.hadoopbook.ch02;

import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;

/**
 * @author WangWeiwei
 * @version 1.0
 * @sine 17-2-4
 * MaxTemperature Application to find the maximum temperature in the weather dataset
 */
public class MaxTemperature {
    public static void main(String[] args) throws Exception{
        if (args.length != 2){
            System.err.println(&quot;Usage: MaxTemperature &lt;input path&gt; &lt;output path&gt;&quot;);
            System.exit(-1);
        }

        Job job = new Job();
        job.setJarByClass(MaxTemperature.class);
        job.setJobName(&quot;Max Temperature&quot;);

        FileInputFormat.addInputPath(job,new Path(args[0]));
        FileOutputFormat.setOutputPath(job,new Path(args[1]));

        job.setMapperClass(MaxTemperatureMapper.class);
        job.setReducerClass(MaxTemperatureReducer.class);

        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(IntWritable.class);

        System.exit(job.waitForCompletion(true) ? 0 : 1);
    }
}
</code></pre><p>   Job对象指定作业的执行规范。我们可以使用它来控制整个作业的运行。我们在Hadoop集群上运行这个作业时，<br>   要把它打包成一个JAR文件（Hadoop在集群上发布这个文件）。不必明确指定JAR文件的名称，在Job对象的<br>   setJarByClass方法中传递一个类即可，Hadoop利用这个类来查找包含它的JAR文件，进而找到相关的JAR文件。</p>
<p>   构造Job对象之后，需要指定输入和输出数据路径。调用FileInputFormat类的静态方法addInputPath()<br>   来定义输入数据的路径，这个路径可以是单个文件/一个目录（此时目录下的所有文件当作输入）或符合特定文件模式的一系列文件。<br>   由函数名可知，可以多次调用addInputPath()方法。</p>
<p>   调用FIleOutFormat类中的静态方法setOutputPath()来指定输出路径，只能有一个输出路径。这个方法指定的是<br>   reduce函数输出文件的写入目录。在运行作业前该目录是不应该存在的，否则Hadoop会报错，并拒绝运行作业。<br>   这种预防措施的目的是防止数据丢失（长时间运行的作业如果结果被意外覆盖，肯定是非常恼人的）</p>
<p>   接着通过setMapperClass()和setReducerClass()指定map类型和reduce类型。</p>
<p>   setOutputKeyClass() 和 setOutputValueClass() 控制map和reduce函数的输出类型。</p>
<p>   在设置定义map和reduce函数的类后，可以开始运行作业。job中的waitForCompletion()方法返回一个布尔值。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/02/04/bigdata/hadoop/并行计算框架介绍/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 weiwei02. All Rights Reserved.
        github空间地址： https://weiwei02.github.io/
        国内空间地址：   https://weiwei02.cording.me/
    </span>
</footer>
<div class="ribbon">
<a href="https://github.com/weiwei02">Fork me on GitHub</a>
</div>
<style type="text/css">
/**
fork me on github logo
*/
.ribbon {
  background-color: #a00;
  overflow: hidden;
  white-space: nowrap;
  /* top left corner */
  position: fixed;
  right: -50px;
  top: 40px;
  /* 45 deg ccw rotation */
  -webkit-transform: rotate(45deg);
     -moz-transform: rotate(45deg);
      -ms-transform: rotate(45deg);
       -o-transform: rotate(45deg);
          transform: rotate(45deg);
  /* shadow */
  -webkit-box-shadow: 0 0 10px #888;
     -moz-box-shadow: 0 0 10px #888;
          box-shadow: 0 0 10px #888;
}
.ribbon a {
  border: 1px solid #faa;
  color: #fff;
  display: block;
  font: bold 81.25% 'Helvetica Neue', Helvetica, Arial, sans-serif;
  margin: 1px 0;
  padding: 10px 50px;
  text-align: center;
  text-decoration: none;
  /* shadow */
  text-shadow: 0 0 5px #444;
}
</style>


            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/weiwei.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">weiwei02</h4>
        
            <div id="about-card-bio"><p>技术，改变世界</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>软件工程师</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                北京，海淀
            </div>
        
        <div>
          <a href="https://weiwei02.github.io/" target="_blank">国外主站</a>
          <a href="https://weiwei02.cording.me/" target="_blank">国内主站</a>
        </div>
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://weiwei02.github.io/2017/02/04/bigdata/hadoop/并行计算框架介绍/">
                            <h3 class="media-heading">MapReduce并行计算框架介绍</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2017年2月4日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://weiwei02.github.io/2017/07/02/jvm/001-java内存模型/">
                            <h3 class="media-heading">java内存模型</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2017年7月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://weiwei02.github.io/2017/07/21/jvm/class文件说明/">
                            <h3 class="media-heading">class文件介绍</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2017年7月21日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://weiwei02.github.io/2017/08/03/database/theory/CAP原理/">
                            <h3 class="media-heading">-数据库原理-数据CAP原理</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2017年8月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://weiwei02.github.io/2017/08/09/framework/网站可伸缩架构分析/">
                            <h3 class="media-heading">-架构设计-应用可伸缩架构分析</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2017年8月9日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 5 篇文章
            </p>
        </div>
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-ivwiy10zeb8fifc4swnhkwneuk64y53w2scmdmtp8thi9cqfxh31aowtroaz.min.js"></script>
<!--SCRIPTS END-->


    </body>
</html>
